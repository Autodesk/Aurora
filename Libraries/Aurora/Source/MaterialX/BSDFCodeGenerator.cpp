// Copyright 2022 Autodesk, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
#include "pch.h"

#include <fstream>
#include <iostream>

#include "BSDFCodeGenerator.h"

// MaterialX headers.
#include <MaterialXCore/Document.h>
#include <MaterialXFormat/Util.h>
#include <MaterialXFormat/XmlIo.h>
#include <MaterialXGenGlsl/GlslResourceBindingContext.h>
#include <MaterialXGenGlsl/GlslShaderGenerator.h>
#include <MaterialXGenGlsl/GlslSyntax.h>
#include <MaterialXGenShader/DefaultColorManagementSystem.h>
#include <MaterialXGenShader/HwShaderGenerator.h>
#include <MaterialXGenShader/Shader.h>
#include <MaterialXGenShader/ShaderStage.h>
#include <MaterialXGenShader/Util.h>
#include <MaterialXRender/LightHandler.h>

#include <iomanip>
#include <sstream>

namespace Aurora
{
namespace MaterialXCodeGen
{

shared_ptr<MaterialX::Document> BSDFCodeGenerator::s_pStdLib;

// Custom shader class used by BSDFCodeGenerator.
class BSDFCodeGeneratorShader : public MaterialX::Shader
{
public:
    // Same ctor arguments as parent class.
    BSDFCodeGeneratorShader(const string& name, MaterialX::ShaderGraphPtr graph) :
        MaterialX::Shader(name, graph)
    {
        // Hard coded GLSL syntax.
        // TODO: Investigate creating a HlslSyntax class.
        _pSyntax = make_shared<MaterialX::GlslSyntax>();

        // A dummy "pixel" stage is used to generate the BSDF code.
        _pStage = make_shared<MaterialX::ShaderStage>(MaterialX::Stage::PIXEL, _pSyntax);
        _stagesMap[MaterialX::Stage::PIXEL] = _pStage;
        _stages.push_back(_pStage.get());

        // Create an input block for the vertex data (stored in global struct)
        auto vd = _pStage->createInputBlock(MaterialX::HW::VERTEX_DATA);
        vd->setInstance("vertexData");

        // Add the required vertex attributes.
        // TODO: These are just educated guesses. How do we work out which attributes are used?
        auto tc0 = vd->add(MaterialX::TypeDesc::get("vector2"), MaterialX::HW::T_TEXCOORD + "_0");
        tc0->setVariable("texCoord");
        auto nw = vd->add(MaterialX::TypeDesc::get("vector3"), MaterialX::HW::T_NORMAL_WORLD);
        nw->setVariable("normal");
        auto tw = vd->add(MaterialX::TypeDesc::get("vector3"), MaterialX::HW::T_TANGENT_WORLD);
        tw->setVariable("tangent");
        // TODO: Should absolutely not just map world position to object position.
        auto po = vd->add(MaterialX::TypeDesc::get("vector3"), MaterialX::HW::T_POSITION_OBJECT);
        po->setVariable("position");
        auto pw = vd->add(MaterialX::TypeDesc::get("vector3"), MaterialX::HW::T_POSITION_WORLD);
        pw->setVariable("position");
    }

    // Get the shader stage created by this shader class.
    shared_ptr<MaterialX::ShaderStage> stage() { return _pStage; }

    // Get the syntax object created by this shader class.
    shared_ptr<MaterialX::GlslSyntax> syntax() { return _pSyntax; }

    // Get the source that was generated by the last emit call.
    string getNewSource()
    {
        const string& allSource = _pStage->getSourceCode();
        size_t p                = _currSourcePosition;
        _currSourcePosition     = allSource.size();
        return allSource.substr(p);
    }

private:
    size_t _currSourcePosition = 0;
    shared_ptr<MaterialX::ShaderStage> _pStage;
    shared_ptr<MaterialX::GlslSyntax> _pSyntax;
};

// Custom shader generator class used by BSDFCodeGenerator.
class BSDFShaderGenerator : public MaterialX::GlslShaderGenerator
{
public:
    BSDFShaderGenerator(const string& mtlxLibPath) : _mtlxLibPath(mtlxLibPath)
    {
        _pGeneratedIncludes    = make_unique<map<string, string>>();
        _pGeneratedDefinitions = make_unique<map<size_t, string>>();
    }

    virtual void emitFunctionDefinition(const MaterialX::ShaderNode& node,
        MaterialX::GenContext& context, MaterialX::ShaderStage& stage) const override
    {
        // Get implementation for node.
        const MaterialX::ShaderNodeImpl& impl = node.getImplementation();
        size_t implHash                       = impl.getHash();

        // Check if we've already generated this implementation.
        // There are lots of checks like this around, but the only way to reliably ensure we don't
        // have duplicated functions is to do it here in the code generator.
        // TODO: Work out a nicer way of doing this.
        if (_pGeneratedDefinitions->find(implHash) != _pGeneratedDefinitions->end())
        {
            return;
        }

        // Add to the map so not emitted next time.
        _pGeneratedDefinitions->insert({ implHash, node.getName() });

        // If not a duplicate just pass to the
        MaterialX::GlslShaderGenerator::emitFunctionDefinition(node, context, stage);
    }

    virtual void emitBlock(const string& str, const MaterialX::FilePath& sourceFilename,
        MaterialX::GenContext& context, MaterialX::ShaderStage& stage) const override
    {
        // Build processed block of source from original.
        string processedBlock = "";

        // Stream the source from original string.
        MaterialX::StringStream stream(str);
        for (string line; std::getline(stream, line);)
        {

            // Look for #include lines, so we can have a custom include functionality.
            size_t pos = line.find("#include");
            if (pos != string::npos)
            {
                // Decode the include line.
                size_t startQuote = line.find_first_of("\"");
                size_t endQuote   = line.find_last_of("\"");
                if (startQuote != string::npos && endQuote != string::npos && endQuote > startQuote)
                {
                    size_t length = (endQuote - startQuote) - 1;
                    if (length)
                    {
                        // Get filename from line.
                        const string filename = line.substr(startQuote + 1, length);

                        // Ensure this include has not been included before, if it has ignore this
                        // line. There are lots of checks like this around, but the only way to
                        // reliably ensure we don't have duplicated functions is to do it here in
                        // the code generator.
                        // TODO: Work out a nicer way of doing this.
                        if (_pGeneratedIncludes->find(filename) == _pGeneratedIncludes->end())
                        {
                            // Read the include file and add to processed block.
                            const string path = _includeFilePaths.at(filename);
                            const string resolvedPath =
                                context.resolveSourceFile(path, _mtlxLibPath);
                            _pGeneratedIncludes->insert({ filename, resolvedPath });
                            string source = MaterialX::readFile(resolvedPath);
                            if (source.empty())
                                AU_ERROR("Failed to load MaterialX GLSL include file:%s",
                                    resolvedPath.c_str());
                            processedBlock += "// Included from " + filename + "\n" + source + "\n";
                        }
                    }
                }
            }
            else
            {
                // All other lines are added with
                processedBlock += line + "\n";
            }
        }

        // Pass the processed block (without include lines) to the parent class emitBlock function.
        MaterialX::GlslShaderGenerator::emitBlock(processedBlock, sourceFilename, context, stage);
    }

    // Replace the upstream result with a temp variable if node+input name match.
    string getUpstreamResult(
        const MaterialX::ShaderInput* input, MaterialX::GenContext& context) const override
    {
        // Use temp variable if full name matches.
        string fullName = input->getNode()->getName() + "_" + input->getName();
        if (_tempVariables.find(fullName) != _tempVariables.end())
        {
            return _tempVariables.at(fullName);
        }

        // Otherwise call parent class method.
        string result = MaterialX::GlslShaderGenerator::getUpstreamResult(input, context);
        return result;
    }

    // Add a temp variable for given input.
    void addTempInputVariable(const MaterialX::ShaderInput* input, string tempName)
    {
        string fullName = input->getNode()->getName() + "_" + input->getName();

        _tempVariables[fullName] = tempName;
    }

    // Clear all the temp variables.
    void clearTempVariables() { _tempVariables.clear(); }

protected:
    map<string, string> _tempVariables;
    unique_ptr<map<size_t, string>> _pGeneratedDefinitions;
    unique_ptr<map<string, string>> _pGeneratedIncludes;
    string _mtlxLibPath;

    // Map of include paths.
    // TOOO: How to know which of these we should have?
    map<string, string> _includeFilePaths = { { "lib/$fileTransformUv",
        "stdlib/genglsl/lib/mx_transform_uv.glsl" } };
};

void BSDFCodeGenerator::createStdLib()
{
    // Setup search path.
    MaterialX::FilePathVec libraryFolders;
    libraryFolders.push_back(_mtlxLibPath);
    MaterialX::FileSearchPath searchPath;
    searchPath.append(_mtlxLibPath.c_str());

    // Create a document to store standard library.
    s_pStdLib = MaterialX::createDocument();

    // Load the standard library.
    auto res = MaterialX::loadLibraries(libraryFolders, searchPath, s_pStdLib);
    AU_ASSERT(
        res.size(), "Failed to load MaterialX standard libraries from %s\n", _mtlxLibPath.c_str());
}

BSDFCodeGenerator::BSDFCodeGenerator(
    const string& mtlxPath, const string& surfaceShaderNodeCategory) :
    _surfaceShaderNodeCategory(surfaceShaderNodeCategory)
{
    // Get the MaterialX library path within the MaterialX folder.
    _mtlxLibPath = mtlxPath + "/libraries";

    // Create the MaterialX standard library if it doesn't exist.
    if (!s_pStdLib)
    {
        createStdLib();
    }

    // Create a GLSL generator and generator context.
    _pGenerator        = make_shared<BSDFShaderGenerator>(_mtlxLibPath);
    _pGeneratorContext = make_unique<MaterialX::GenContext>(_pGenerator);

    // Create unit system.
    _unitSystem   = MaterialX::UnitSystem::create(_pGenerator->getTarget());
    _unitRegistry = MaterialX::UnitConverterRegistry::create();
    MaterialX::UnitTypeDefPtr distanceTypeDef = s_pStdLib->getUnitTypeDef("distance");

    // Add create and register unit converter.
    MaterialX::UnitConverterPtr uconverter =
        MaterialX::LinearUnitConverter::create(distanceTypeDef);
    _unitRegistry->addUnitConverter(distanceTypeDef, uconverter);

    // Setup unit system.
    _unitSystem->loadLibrary(s_pStdLib);
    _unitSystem->setUnitConverterRegistry(_unitRegistry);

    // Get the names of the unit definitions and their indices so client code can access them.
    auto unitDefs = distanceTypeDef->getUnitDefs();
    _units.names.clear();
    _units.indices.clear();
    while (true)
    {
        // Get the name for current index..
        int idx     = (int)_units.names.size();
        string unit = uconverter->getUnitFromInteger(idx);
        if (unit.empty())
            break;

        // Add to array and map.
        _units.indices[unit] = idx;
        _units.names.push_back(unit);
    }

    // Set the unit system in the generator.
    _pGenerator->setUnitSystem(_unitSystem);
    _pGeneratorContext->getOptions().targetDistanceUnit = "centimeter"; // NOTE: this is not used.

    // Setup library search path to find libraries.
    MaterialX::FileSearchPath searchPath;
    searchPath.append(_mtlxLibPath.c_str());
    _pGeneratorContext->registerSourceCodeSearchPath(searchPath);

    _defaultOutputParamMapping = { { "base", "base" }, { "base_color", "baseColor" },
        { "diffuse_roughness", "diffuseRoughness" }, { "specular_roughness", "specularRoughness" },
        { "specular", "specular" }, { "sheen", "sheen" }, { "sheen_roughness", "sheenRoughness" },
        { "sheen_color", "sheenColor" }, { "specular_color", "specularColor" },
        { "metalness", "metalness" } };
    _defaultOutputMapper       = [&](const string& name, Aurora::IValues::Type /*type*/,
                               const string& /*topLevelShaderName*/) {
        auto iter = _defaultOutputParamMapping.find(name);
        if (iter != _defaultOutputParamMapping.end())
            return iter->second;
        return string("");
    };
}

// Empty dtor in C++ file, to avoid issues with forward declaring MaterialX types.
BSDFCodeGenerator::~BSDFCodeGenerator() {}

void BSDFCodeGenerator::processInput(MaterialX::ShaderInput* input,
    shared_ptr<BSDFCodeGeneratorShader> pBSDFGenShader, const string& outputVariable,
    string* pSourceOut)
{
    // Do we need local scope to avoid name collisions?
    bool addScope = false;

    // Get the shader stage.
    MaterialX::ShaderStage& ps = pBSDFGenShader->getStage(MaterialX::Stage::PIXEL);

    // Get the connection for the input (warn if null.)
    auto connection = input->getConnection();

    // Ignore input if no connection.
    // TODO: Handle this case.
    if (!connection)
    {
        AU_WARN("Input %s has no connection, ignoring.", input->getFullName().c_str());
        return;
    }

    // Compare connection name.
    string variableName = connection->getFullName();
    if (input->getConnection()->getNode()->getName() == "BSDFCodeGeneratorShaderGraph")
    {
        // If this a connection from the high-level shader graph, its a material input.
        auto inputName = input->getFullName();

        IValues::Type auroraInputType =
            glslTypeToAuroraType(pBSDFGenShader->syntax()->getTypeName(input->getType()));

        string mappedName =
            _currentInputParameterMapper(inputName, auroraInputType, _topLevelShaderNodeName);
        pSourceOut->append("\t// Graph input " + inputName + "\n");
        if (mappedName.empty())
        {
            // MtlX code gen requires a scope, but we comment it out so variable scope not effected.
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL).addValue("//");
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL)
                .beginScope(MaterialX::Syntax::CURLY_BRACKETS);

            // If this is not one of the material inputs from _materialInputs emit with hard-coded
            // default value.
            _pGenerator->emitVariableDeclaration(input, "", *_pGeneratorContext, ps, true);

            // End the scope for declaration.
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL).addValue("//");
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL)
                .endScope(MaterialX::Syntax::CURLY_BRACKETS);
            pSourceOut->append("\t" + pBSDFGenShader->getNewSource() + ";\n");
        }
        else
        {
            // MtlX code gen requires a scope, but we comment it out so variable scope not effected.
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL).addValue("//");
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL)
                .beginScope(MaterialX::Syntax::CURLY_BRACKETS);

            // If this is one of the material inputs from _materialInputs, set it using the function
            // parameter for that input.
            _pGenerator->emitVariableDeclaration(input, "", *_pGeneratorContext, ps, false);

            // End the decleration scope.
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL).addValue("//");
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL)
                .endScope(MaterialX::Syntax::CURLY_BRACKETS);

            pSourceOut->append("\t" + pBSDFGenShader->getNewSource());
            pSourceOut->append(" = " + mappedName + _materialInputSuffix + ";\n");

            // Mark this input as active.
            if (_activeInputs.find(mappedName) == _activeInputs.end())
                _activeInputNames.push_back(mappedName);

            _activeInputs[mappedName] = make_pair(
                pBSDFGenShader->syntax()->getTypeName(input->getType()), input->getValue());
        }

        // Set the variable name that will used to generate the output.result.
        variableName = input->getVariable();
    }
    else
    {
        // Get the node this connection is from and its implementation string.
        auto node       = connection->getNode();
        string implName = node->getImplementation().getName();

        // Create a temp variable to store the node ouput, if this node has already been generated
        // then this will be reused without generating again.
        // TODO: Handle multiple outputs.
        string outputTempVariable =
            "nodeOutTmp_" + connection->getNode()->getName() + "_" + connection->getName();

        // Only process the input if it hasn't already been processed.
        if (_processedNodes.find(node) == _processedNodes.end())
        {
            _processedNodes.insert(node);

            // Generate temp variables for the inputs, to avoid name collisions.
            auto inputs = node->getInputs();
            pSourceOut->append("\t//Temp input variables for " + node->getName() + " \n");

            // Create a temp output variable to store any externally-facing outputs.
            pSourceOut->append("\t" + pBSDFGenShader->syntax()->getTypeName(connection->getType()) +
                " " + outputTempVariable + "; //Temp output variable for " + connection->getName() +
                " \n");

            vector<string> outputVars;
            for (int i = 0; i < inputs.size(); i++)
            {
                // Get the input name and connection name it is coming from..
                auto nodeInput = inputs[i];
                string inputTempVariable =
                    "nodeTmp_" + nodeInput->getNode()->getName() + "_" + nodeInput->getName();

                // Create temp variable
                string inputType = pBSDFGenShader->syntax()->getTypeName(nodeInput->getType());
                pSourceOut->append("\t" + inputType + " " + inputTempVariable +
                    "; //Temp input variable for " + nodeInput->getName() + " \n");

                // Add to output variables.(passed to upstream input nodes) and code generator.
                outputVars.push_back(inputTempVariable);
                _pGenerator->addTempInputVariable(nodeInput, inputTempVariable);
            }

            // Recursively process inputs.
            for (int i = 0; i < inputs.size(); i++)
            {
                auto nodeInput = inputs[i];
                processInput(nodeInput, pBSDFGenShader, outputVars[i], pSourceOut);
            }

            // Check if we already have a definition for this node's implementation.
            // The definitions are shared between documents, and calls to generate.
            auto defIter           = _definitionMap.find(implName);
            size_t definitionIndex = 0xFFFFFFFF;
            if (defIter != _definitionMap.end())
            {
                definitionIndex = defIter->second;
            }
            else
            {
                // MtlX code gen requires a scope, but we comment it out so variable scope not
                // effected.
                pBSDFGenShader->getStage(MaterialX::Stage::PIXEL).addValue("//");
                pBSDFGenShader->getStage(MaterialX::Stage::PIXEL)
                    .beginScope(MaterialX::Syntax::CURLY_BRACKETS);

                // If not already generated (and not an empty string), store the function
                // definition.
                _pGenerator->emitFunctionDefinition(*node, *_pGeneratorContext, ps);

                // End scope for definition.
                pBSDFGenShader->getStage(MaterialX::Stage::PIXEL).addValue("//");
                pBSDFGenShader->getStage(MaterialX::Stage::PIXEL)
                    .endScope(MaterialX::Syntax::CURLY_BRACKETS);

                string defSource = pBSDFGenShader->getNewSource();
                if (defSource.size())
                {
                    definitionIndex          = _definitions.size();
                    _definitionMap[implName] = definitionIndex;
                    _definitions.push_back(
                        "\n// Definition for implementation " + implName + "\n" + defSource);
                }
            }

            // Begin with comment (referencing definition if there is one)
            pSourceOut->append("\t// Graph input function call " + input->getName());
            if (definitionIndex != 0xFFFFFFFF)
            {
                pSourceOut->append(" (See definition " + implName + ")");
            }
            pSourceOut->append("\n");

            // To avoid name collisions add local scope.
            // TODO: Fix indentation.
            pSourceOut->append("{\n");
            addScope = true;

            // MtlX code gen requires a scope, but we comment it out so variable scope not
            // effected.
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL).addValue("//");
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL)
                .beginScope(MaterialX::Syntax::CURLY_BRACKETS);

            // Emit function call for this input.
            _pGenerator->emitFunctionCall(*node, *_pGeneratorContext, ps);

            // End scope for function call.
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL).addValue("//");
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL)
                .endScope(MaterialX::Syntax::CURLY_BRACKETS);

            pSourceOut->append("\t" + pBSDFGenShader->getNewSource());

            //
            pSourceOut->append("\t" + outputTempVariable);
            pSourceOut->append(" = " + variableName + ";// Output connection\n");
        }
        else
        {
            variableName = outputTempVariable;
        }
    }

    // Copy this output to the provided
    if (outputVariable.size())
    {
        pSourceOut->append("\t" + outputVariable);
        pSourceOut->append(" = " + variableName + ";// Output connection\n");
    }

    // End local scope (ensuring output variable setter is enclosed.)
    if (addScope)
    {
        pSourceOut->append("}\n");
    }
}

void BSDFCodeGenerator::clearDefinitions()
{
    // Clear the definitions, which are accumulated after each generate call.
    _definitions.clear();
    _definitionMap.clear();
}

int BSDFCodeGenerator::generateDefinitions(string* pResultOut)
{
    // Combine the GLSL code stored in the definitions vector.
    *pResultOut = "";
    for (int i = 0; i < _definitions.size(); i++)
    {
        pResultOut->append(_definitions[i]);
    }

    // Return number of definitions.
    return (int)_definitions.size();
}

bool BSDFCodeGenerator::materialXValueToAuroraValue(
    Value* pValueOut, shared_ptr<MaterialX::Value> pMtlXValue)
{
    *pValueOut = Value();

    string glslType = pMtlXValue->getTypeString();
    if (glslType.compare("color3") == 0)
    {
        MaterialX::Color3 valData = pMtlXValue->asA<MaterialX::Color3>();
        *pValueOut                = glm::vec3(valData[0], valData[1], valData[2]);
        return true;
    }
    if (glslType.compare("vector2") == 0)
    {
        MaterialX::Vector2 valData = pMtlXValue->asA<MaterialX::Vector2>();
        *pValueOut                 = glm::vec2(valData[0], valData[1]);
        return true;
    }
    if (glslType.compare("boolean") == 0)
    {
        bool valData = pMtlXValue->asA<bool>();
        *pValueOut   = valData;
        return true;
    }
    if (glslType.compare("integer") == 0)
    {
        int valData = pMtlXValue->asA<int>();
        *pValueOut  = valData;
        return true;
    }
    if (glslType.compare("float") == 0)
    {
        float valData = pMtlXValue->asA<float>();
        *pValueOut    = valData;
        return true;
    }
    if (glslType.compare("string") == 0)
    {
        string valData = pMtlXValue->asA<string>();
        *pValueOut     = valData;
        return true;
    }

    return false;
}

IValues::Type BSDFCodeGenerator::glslTypeToAuroraType(const string glslType)
{
    // Set the aurora type based on GLSL type string.
    if (glslType.compare("vec3") == 0)
        return IValues::Type::Float3;
    if (glslType.compare("vec2") == 0)
        return IValues::Type::Float2;
    if (glslType.compare("float") == 0)
        return IValues::Type::Float;
    if (glslType.compare("sampler2D") == 0)
        return IValues::Type::Image;
    if (glslType.compare("int") == 0)
        return IValues::Type::Int;
    if (glslType.compare("bool") == 0)
        return IValues::Type::Boolean;

    // Fail if no valid mapping found.
    AU_FAIL("Unsupported GLSL type %s", glslType.c_str());
    return IValues::Type::Undefined;
}

bool BSDFCodeGenerator::generate(const string& document, BSDFCodeGenerator::Result* pResultOut,
    ParameterMappingFunction inputParameterMapper, ParameterMappingFunction outputParameterMapper,
    const string& overrideDocumentName)
{
    // Processed MaterialX document string.
    string processedMtlXDocument;

    // Process the document string to replace document name if override name provided.
    if (!overrideDocumentName.empty())
    {
        // Regular expression to find strings in the form:
        //     <materialx version="1.38" colorspace="lin_rec709">  <standard_surface name =
        //     "XID_PlasticBlack"
        // and then retreive document name: XID_PlasticBlack
        std::regex rgx("<\\s*materialx[^>]+>\\s*<\\s*\\S+\\s+name=\"([^\"]+)\"");
        std::smatch match;

        // Create a copy of document string.
        processedMtlXDocument = document;

        // Search for matches to the document name reg exp.
        if (std::regex_search(processedMtlXDocument, match, rgx))
        {
            // Retreive the sub-expression with the document name.
            string documentName = match[1];

            // Replace all occurrences of document name with the overide value.
            processedMtlXDocument =
                Foundation::replace(processedMtlXDocument, documentName, overrideDocumentName);
        }
        else
        {
            // Warn if the regular expression fails.
            AU_WARN("Failed to find document name in MaterialX XML");
        }
    }

    // Get reference to original or processed materialX document string.
    const string& mtlXDocument = processedMtlXDocument.empty() ? document : processedMtlXDocument;

    // Set the current input an output mappers to provided values.
    _currentInputParameterMapper = inputParameterMapper;
    _currentOutputParameterMapper =
        outputParameterMapper ? outputParameterMapper : _defaultOutputMapper;

    _pGenerator->clearTempVariables();
    _processedNodes.clear();

    // Clear the setup code string.
    pResultOut->materialSetupCode = "";

    // Create new document object.
    MaterialX::DocumentPtr mtlxDocument = MaterialX::createDocument();

    // Read the XML into the document.
    try
    {
        MaterialX::readFromXmlString(mtlxDocument, mtlXDocument);
    }
    catch (const MaterialX::Exception& exception)
    {
        AU_ERROR("Failed to read MaterialX from document:\n%s\n", exception.what());
        return false;
    }

    _unitRegistry->write(mtlxDocument);

    string errorMessage;
    if (!mtlxDocument->validate(&errorMessage))
    {
        AU_ERROR("Invalid MaterialX document:\n%s", errorMessage.c_str());
        return false;
    }

    // Import the standard library.
    mtlxDocument->importLibrary(s_pStdLib);

    // Setup include paths.
    // TODO: This is just a guess.  How do we ensure all required includes are provided?
    MaterialX::StringMap& tokenSub =
        const_cast<MaterialX::StringMap&>(_pGenerator->getTokenSubstitutions());
    tokenSub["$fileTransformUv"] = "stdlib/genglsl/lib/mx_transform_uv.glsl";

    // Find renderable nodes.
    vector<MaterialX::TypedElementPtr> elements;
    unordered_set<MaterialX::ElementPtr> processedOutputs;
    MaterialX::findRenderableMaterialNodes(mtlxDocument, elements, false, processedOutputs);

    // Return false if no renderable nodes.
    // TODO: Better error handling.
    if (elements.size() == 0)
    {
        AU_ERROR("No renderable nodes in MaterialX document");
        return false;
    }

    // Assume material is first element in the XML file.
    string materialNodeName = elements[0]->getName();

    // Get the material nodes, return false if empty.
    // TODO: Better error handling.
    auto materialNodes = mtlxDocument->getMaterialNodes();
    if (elements.size() == 0)
    {
        AU_ERROR("Empty material in MaterialX document");
        return false;
    }

    // Find the material node using name from element.
    MaterialX::NodePtr materialNode = nullptr;
    for (int i = 0; i < materialNodes.size(); i++)
    {
        if (materialNodes[i]->getName() == materialNodeName)
        {
            materialNode = materialNodes[i];
            break;
        }
    }

    // Return false if find failed.
    // TODO: Better error handling.
    if (materialNode == nullptr)
    {
        AU_ERROR("Failed to find material node");
        return false;
    }

    // Get the shader nodes.
    vector<MaterialX::NodePtr> shaderNodes = MaterialX::getShaderNodes(materialNode);
    if (shaderNodes.empty())
    {
        AU_ERROR("No shader nodes in MaterialX document");
        return false;
    }

    // Find the surface node for shader.
    MaterialX::TypedElementPtr shaderNodeElement     = nullptr;
    MaterialX::InterfaceElementPtr shaderNodeDefImpl = nullptr;
    for (MaterialX::NodePtr shaderNode : shaderNodes)
    {
        if ((shaderNode->getType() == MaterialX::SURFACE_SHADER_TYPE_STRING) &&
            (shaderNode->getCategory() == _surfaceShaderNodeCategory))
        {
            shaderNodeElement = shaderNode;

            // Find the nodegraph implementation of the surface node.
            shaderNodeDefImpl = shaderNodeElement->asA<MaterialX::Node>()->getImplementation();

            if (shaderNodeDefImpl)
                break;
        }
    }
    if (!shaderNodeElement)
    {
        AU_ERROR("Failed to find surface shader in material");
        return false;
    }
    if (!shaderNodeDefImpl)
    {
        AU_ERROR("Failed to find nodegraph implementation for the surface shader");
        return false;
    }

    string surfaceShaderNodeType = shaderNodeDefImpl->getName();

    // Create a shader graph from the surface node.
    MaterialX::ShaderGraphPtr graph = MaterialX::ShaderGraph::create(
        nullptr, "BSDFCodeGeneratorShaderGraph", shaderNodeElement, *_pGeneratorContext);
    shared_ptr<BSDFCodeGeneratorShader> pBSDFGenShader =
        make_shared<BSDFCodeGeneratorShader>("BSDFCodeGeneratorShader", graph);
    MaterialX::ShaderPtr shader = dynamic_pointer_cast<MaterialX::Shader>(pBSDFGenShader);

    // Find the surface shader node.
    MaterialX::ShaderNode* surfaceShaderNode = nullptr;
    for (MaterialX::ShaderNode* node : graph->getNodes())
    {
        if (node->getImplementation().getName() == surfaceShaderNodeType)
        {
            surfaceShaderNode = node;
            break;
        }
    }
    if (!surfaceShaderNode)
    {
        AU_ERROR("No surface shader node of type %s found", surfaceShaderNodeType.c_str());
        return false;
    }

    _topLevelShaderNodeName = surfaceShaderNode->getName();

    // Create the active inputs and outputs.
    _activeOutputs.clear();
    _activeInputs.clear();
    _activeInputNames.clear();
    _activeOutputNames.clear();

    // Build the body of the setup function from the surface shader node inputs.
    string functionBody      = "";
    auto surfaceShaderInputs = surfaceShaderNode->getInputs();
    for (int ssi = 0; ssi < surfaceShaderInputs.size(); ssi++)
    {

        // Is this shader input one of the outputs we are interested in ?
        auto surfaceShaderInput = surfaceShaderInputs[ssi];

        IValues::Type auroraoOutputType = glslTypeToAuroraType(
            pBSDFGenShader->syntax()->getTypeName(surfaceShaderInput->getType()));
        string outputVariable = _currentOutputParameterMapper(
            surfaceShaderInput->getName(), auroraoOutputType, _topLevelShaderNodeName);

        if (!outputVariable.empty())
        {
            // Process the shader input.
            processInput(surfaceShaderInput, pBSDFGenShader, outputVariable, &functionBody);

            // Add type to active outputs.
            _activeOutputNames.push_back(outputVariable);
            _activeOutputs[outputVariable] =
                pBSDFGenShader->syntax()->getTypeName(surfaceShaderInput->getType());
        };
    }

    // Create a hash from the contents of the setup function. This is used to uniquely identify the
    // shader code generated for this material, without any of the parameters or other surrounding
    // data.
    pResultOut->functionHash = hash<string> {}(functionBody);

    // Create setup function name from hash.
    stringstream sstream;
    sstream << "setupMaterial_" << Foundation::sHash(pResultOut->functionHash);
    pResultOut->setupFunctionName = sstream.str();

    // Create the function prototype from the function name, active inputs and outputs.
    pResultOut->materialSetupCode = "void " + pResultOut->setupFunctionName + "(\n";

    // Keep track of total input and output parameter count.
    int numParams = 0;

    // Clear the argument and default values vectors.
    pResultOut->argumentsUsed.clear();
    pResultOut->defaultInputValues.clear();
    pResultOut->defaultInputValues.resize(_activeInputNames.size());

    // Add the material inputs to the function prototype.
    for (int i = 0; i < _activeInputNames.size(); i++)
    {
        auto inputVar = _activeInputNames[i];

        auto activeTypeIter = _activeInputs.find(inputVar);
        if (activeTypeIter != _activeInputs.end())
        {
            auto activeInput       = activeTypeIter->second;
            string activeInputType = activeInput.first;

            // Create variable name using input name and suffix.
            string inputVarName = inputVar + _materialInputSuffix;

            // Append comma to previous line, if any.
            if (numParams)
                pResultOut->materialSetupCode.append(",\n");

            // Convert GLSL type to Aurora type enum.
            IValues::Type auroraType = glslTypeToAuroraType(activeInputType);

            // Convert MaterialX value for input into Aurora Value.
            if (activeInput.second)
            {
                materialXValueToAuroraValue(&pResultOut->defaultInputValues[i], activeInput.second);
            }
            Value* pDefaultValue = &pResultOut->defaultInputValues[i];

            // Add this input to the results.
            pResultOut->argumentsUsed.push_back({ inputVar, auroraType, false, pDefaultValue });

            // Add the code for this input to the prototype.
            pResultOut->materialSetupCode.append("\t" + activeInputType + " " + inputVarName);

            // Increment parameter count.
            numParams++;
        }
    }

    // Add the material outputs to the function prototype.
    for (auto outputVar : _activeOutputNames)
    {
        auto activeTypeIter = _activeOutputs.find(outputVar);
        if (activeTypeIter != _activeOutputs.end())
        {
            // Create variable name using output name and suffix.
            string outputVarName = outputVar + _materialOutputSuffix;

            // Append comma to previous line, if any.
            if (numParams)
                pResultOut->materialSetupCode.append(",\n");

            // Convert GLSL type to Aurora type enum.
            IValues::Type auroraType = glslTypeToAuroraType(activeTypeIter->second);

            // Add this output to the results.
            pResultOut->argumentsUsed.push_back({ outputVar, auroraType, true });

            // Add the code for this output to the prototype.
            pResultOut->materialSetupCode.append(
                "\tout " + activeTypeIter->second + " " + outputVarName);

            // Increment parameter count.
            numParams++;
        }
    }

    // Add body wrapped in braces.
    pResultOut->materialSetupCode.append(")\n{\n");
    pResultOut->materialSetupCode.append(functionBody);
    pResultOut->materialSetupCode.append("}\n");

    return true;
};

} // namespace MaterialXCodeGen
} // namespace Aurora
