//
// Copyright 2023 by Autodesk, Inc.  All rights reserved.
//
// This computer source code and related instructions and comments
// are the unpublished confidential and proprietary information of
// Autodesk, Inc. and are protected under applicable copyright and
// trade secret law.  They may not be disclosed to, copied or used
// by any third party without the prior written consent of Autodesk, Inc.
//
#include "pch.h"

#include <fstream>
#include <iostream>

#include "BSDFCodeGenerator.h"

// MaterialX headers.
#include <MaterialXCore/Document.h>
#include <MaterialXFormat/Util.h>
#include <MaterialXFormat/XmlIo.h>
#include <MaterialXGenGlsl/GlslResourceBindingContext.h>
#include <MaterialXGenGlsl/GlslShaderGenerator.h>
#include <MaterialXGenGlsl/GlslSyntax.h>
#include <MaterialXGenShader/DefaultColorManagementSystem.h>
#include <MaterialXGenShader/HwShaderGenerator.h>
#include <MaterialXGenShader/Shader.h>
#include <MaterialXGenShader/ShaderStage.h>
#include <MaterialXGenShader/Util.h>
#include <MaterialXRender/LightHandler.h>

#include <iomanip>
#include <sstream>

namespace Aurora
{
namespace MaterialXCodeGen
{

shared_ptr<MaterialX::Document> BSDFCodeGenerator::s_pStdLib;

// Custom shader class used by BSDFCodeGenerator.
class BSDFCodeGeneratorShader : public MaterialX::Shader
{
public:
    // Same ctor arguments as parent class.
    BSDFCodeGeneratorShader(const string& name, MaterialX::ShaderGraphPtr graph) :
        MaterialX::Shader(name, graph)
    {
        // Hard coded GLSL syntax.
        // TODO: Investigate creating a HlslSyntax class.
        _pSyntax = make_shared<MaterialX::GlslSyntax>();

        // A dummy "pixel" stage is used to generate the BSDF code.
        _pStage = make_shared<MaterialX::ShaderStage>(MaterialX::Stage::PIXEL, _pSyntax);
        _stagesMap[MaterialX::Stage::PIXEL] = _pStage;
        _stages.push_back(_pStage.get());

        // Create an input block for the vertex data (stored in global struct)
        auto vd = _pStage->createInputBlock(MaterialX::HW::VERTEX_DATA);
        vd->setInstance("vertexData");

        // Add the required vertex attributes.
        // TODO: These are just educated guesses. How do we work out which attributes are used?
        auto tc0 = vd->add(MaterialX::TypeDesc::get("vector2"), MaterialX::HW::T_TEXCOORD + "_0");
        tc0->setVariable("texCoord");
        auto no = vd->add(MaterialX::TypeDesc::get("vector3"), MaterialX::HW::T_NORMAL_OBJECT);
        no->setVariable("objectNormal");
        auto nw = vd->add(MaterialX::TypeDesc::get("vector3"), MaterialX::HW::T_NORMAL_WORLD);
        nw->setVariable("normal");
        auto tw = vd->add(MaterialX::TypeDesc::get("vector3"), MaterialX::HW::T_TANGENT_WORLD);
        tw->setVariable("tangent");
        auto po = vd->add(MaterialX::TypeDesc::get("vector3"), MaterialX::HW::T_POSITION_OBJECT);
        po->setVariable("objectPosition");
        auto pw = vd->add(MaterialX::TypeDesc::get("vector3"), MaterialX::HW::T_POSITION_WORLD);
        pw->setVariable("position");
    }

    // Get the shader stage created by this shader class.
    shared_ptr<MaterialX::ShaderStage> stage() { return _pStage; }

    // Get the syntax object created by this shader class.
    shared_ptr<MaterialX::GlslSyntax> syntax() { return _pSyntax; }

    // Get the source that was generated by the last emit call.
    string getNewSource()
    {
        const string& allSource = _pStage->getSourceCode();
        size_t p                = _currSourcePosition;
        _currSourcePosition     = allSource.size();
        return allSource.substr(p);
    }

private:
    size_t _currSourcePosition = 0;
    shared_ptr<MaterialX::ShaderStage> _pStage;
    shared_ptr<MaterialX::GlslSyntax> _pSyntax;
};

// Custom shader generator class used by BSDFCodeGenerator.
class BSDFShaderGenerator : public MaterialX::GlslShaderGenerator
{
public:
    BSDFShaderGenerator(const string& mtlxLibPath) : _mtlxLibPath(mtlxLibPath)
    {
        _pGeneratedIncludes    = make_unique<map<string, string>>();
        _pGeneratedDefinitions = make_unique<map<size_t, string>>();
    }

    virtual void emitFunctionDefinition(const MaterialX::ShaderNode& node,
        MaterialX::GenContext& context, MaterialX::ShaderStage& stage) const override
    {
        // Get implementation for node.
        const MaterialX::ShaderNodeImpl& impl = node.getImplementation();
        size_t implHash                       = impl.getHash();

        // Check if we've already generated this implementation.
        // There are lots of checks like this around, but the only way to reliably ensure we don't
        // have duplicated functions is to do it here in the code generator.
        // TODO: Work out a nicer way of doing this.
        if (_pGeneratedDefinitions->find(implHash) != _pGeneratedDefinitions->end())
        {
            return;
        }

        // Add to the map so not emitted next time.
        _pGeneratedDefinitions->insert({ implHash, node.getName() });

        // If not a duplicate just pass to the
        MaterialX::GlslShaderGenerator::emitFunctionDefinition(node, context, stage);
    }

    virtual void emitBlock(const string& str, const MaterialX::FilePath& sourceFilename,
        MaterialX::GenContext& context, MaterialX::ShaderStage& stage) const override
    {
        // Build processed block of source from original.
        string processedBlock = "";

        // Stream the source from original string.
        MaterialX::StringStream stream(str);
        for (string line; std::getline(stream, line);)
        {

            // Look for #include lines, so we can have a custom include functionality.
            size_t pos = line.find("#include");
            if (pos != string::npos)
            {
                // Decode the include line.
                size_t startQuote = line.find_first_of("\"");
                size_t endQuote   = line.find_last_of("\"");
                if (startQuote != string::npos && endQuote != string::npos && endQuote > startQuote)
                {
                    size_t length = (endQuote - startQuote) - 1;
                    if (length)
                    {
                        // Get filename from line.
                        const string filename = line.substr(startQuote + 1, length);

                        // Ensure this include has not been included before, if it has ignore this
                        // line. There are lots of checks like this around, but the only way to
                        // reliably ensure we don't have duplicated functions is to do it here in
                        // the code generator.
                        // TODO: Work out a nicer way of doing this.
                        if (_pGeneratedIncludes->find(filename) == _pGeneratedIncludes->end())
                        {
                            // Read the include file and add to processed block.
                            const string path = _includeFilePaths.at(filename);
                            const string resolvedPath =
                                context.resolveSourceFile(path, _mtlxLibPath);
                            _pGeneratedIncludes->insert({ filename, resolvedPath });
                            string source = MaterialX::readFile(resolvedPath);
                            if (source.empty())
                                AU_ERROR("Failed to load MaterialX GLSL include file:%s",
                                    resolvedPath.c_str());
                            processedBlock += "// Included from " + filename + "\n" + source + "\n";
                        }
                    }
                }
            }
            else
            {
                // All other lines are added with
                processedBlock += line + "\n";
            }
        }

        // Pass the processed block (without include lines) to the parent class emitBlock function.
        MaterialX::GlslShaderGenerator::emitBlock(processedBlock, sourceFilename, context, stage);
    }

    // Replace the upstream result with a temp variable if node+input name match.
    string getUpstreamResult(
        const MaterialX::ShaderInput* input, MaterialX::GenContext& context) const override
    {
        // Use temp variable if full name matches.
        string fullName = input->getNode()->getName() + "_" + input->getName();
        if (_tempVariables.find(fullName) != _tempVariables.end())
        {
            return _tempVariables.at(fullName);
        }

        // Otherwise call parent class method.
        string result = MaterialX::GlslShaderGenerator::getUpstreamResult(input, context);
        return result;
    }

    // Add a temp variable for given input.
    void addTempInputVariable(const MaterialX::ShaderInput* input, string tempName)
    {
        string fullName = input->getNode()->getName() + "_" + input->getName();

        _tempVariables[fullName] = tempName;
    }

    // Clear all the temp variables.
    void clearTempVariables() { _tempVariables.clear(); }

    // Clear the generated definitions and includes.
    void clearGeneratedDefinitions()
    {
        _pGeneratedDefinitions->clear();
        _pGeneratedIncludes->clear();
    }

protected:
    map<string, string> _tempVariables;
    unique_ptr<map<size_t, string>> _pGeneratedDefinitions;
    unique_ptr<map<string, string>> _pGeneratedIncludes;
    string _mtlxLibPath;

    // Map of include paths.
    // TODO: How to know which of these we should have?
    map<string, string> _includeFilePaths = { { "lib/$fileTransformUv",
        "stdlib/genglsl/lib/mx_transform_uv.glsl" } };
};

void BSDFCodeGenerator::createStdLib()
{
    // Setup search path.
    MaterialX::FilePathVec libraryFolders;
    libraryFolders.push_back(_mtlxLibPath);
    MaterialX::FileSearchPath searchPath;
    searchPath.append(_mtlxLibPath.c_str());

    // Create a document to store standard library.
    s_pStdLib = MaterialX::createDocument();

    // Load the standard library.
    auto res = MaterialX::loadLibraries(libraryFolders, searchPath, s_pStdLib);
    AU_ASSERT(
        res.size(), "Failed to load MaterialX standard libraries from %s\n", _mtlxLibPath.c_str());
}

BSDFCodeGenerator::BSDFCodeGenerator(
    const string& mtlxPath, const string& surfaceShaderNodeCategory) :
    _surfaceShaderNodeCategory(surfaceShaderNodeCategory)
{
    // Get the MaterialX library path within the MaterialX folder.
    _mtlxLibPath = mtlxPath + "/libraries";

    // Create the MaterialX standard library if it doesn't exist.
    if (!s_pStdLib)
    {
        createStdLib();
    }

    // Create a GLSL generator and generator context.
    _pGenerator        = make_shared<BSDFShaderGenerator>(_mtlxLibPath);
    _pGeneratorContext = make_unique<MaterialX::GenContext>(_pGenerator);

    // Create unit system.
    _unitSystem   = MaterialX::UnitSystem::create(_pGenerator->getTarget());
    _unitRegistry = MaterialX::UnitConverterRegistry::create();
    MaterialX::UnitTypeDefPtr distanceTypeDef = s_pStdLib->getUnitTypeDef("distance");

    // Add create and register unit converter.
    MaterialX::UnitConverterPtr uconverter =
        MaterialX::LinearUnitConverter::create(distanceTypeDef);
    _unitRegistry->addUnitConverter(distanceTypeDef, uconverter);

    // Setup unit system.
    _unitSystem->loadLibrary(s_pStdLib);
    _unitSystem->setUnitConverterRegistry(_unitRegistry);

    // Get the names of the unit definitions and their indices so client code can access them.
    auto unitDefs = distanceTypeDef->getUnitDefs();
    _units.names.clear();
    _units.indices.clear();
    while (true)
    {
        // Get the name for current index..
        int idx     = (int)_units.names.size();
        string unit = uconverter->getUnitFromInteger(idx);
        if (unit.empty())
            break;

        // Add to array and map.
        _units.indices[unit] = idx;
        _units.names.push_back(unit);
    }

    // Set the unit system in the generator.
    _pGenerator->setUnitSystem(_unitSystem);
    _pGeneratorContext->getOptions().targetDistanceUnit = "centimeter"; // NOTE: this is not used.

    // Setup library search path to find libraries.
    MaterialX::FileSearchPath searchPath;
    searchPath.append(_mtlxLibPath.c_str());
    _pGeneratorContext->registerSourceCodeSearchPath(searchPath);
}

// Convert path name (e.g. foo/bar/value) to a C-like variable name (e.g. foo_bar_value).
string pathToVariableName(const string& propPath)
{

    string invalidChars = " .\\/:~()*+$#@";
    string varName;

    varName.reserve(propPath.length());

    for (size_t i = 0; i < propPath.length(); i++)
    {
        bool valid = true;
        for (size_t j = 0; j < invalidChars.length(); j++)
        {
            if (propPath[i] == invalidChars[j])
            {
                valid = false;
                break;
            }
        }
        if (valid)
            varName += propPath[i];
        else
            varName += "_";
    }

    return varName;
}

// Process path and remove first (and, optionally, last) section.
string processPath(const string& propPath, bool removeLastSection)
{
    string res;
    size_t firstSlash = propPath.find("/");
    if (firstSlash == string::npos)
        res = propPath;
    else
        res = propPath.substr(firstSlash + 1);

    if (removeLastSection)
    {
        size_t lastSlash = res.rfind("/");
        if (lastSlash != string::npos)
            res = res.substr(0, lastSlash);
    }

    return res;
}

// Convert property type to GLSL string type name.
string getGLSLStringFromType(PropertyValue::Type type)
{
    switch (type)
    {
    case PropertyValue::Type::Bool:
        return "int";
    case PropertyValue::Type::Int:
        return "int";
    case PropertyValue::Type::Float:
        return "float";
    case PropertyValue::Type::Float2:
        return "vec2";
    case PropertyValue::Type::Float3:
        return "vec3";
    case PropertyValue::Type::Float4:
        return "vec4";
    case PropertyValue::Type::Matrix4:
        return "mat4";
    default:
        AU_FAIL("Unsupported type for uniform block:%x", type);
        return 0;
    }
}

// Empty dtor in C++ file, to avoid issues with forward declaring MaterialX types.
BSDFCodeGenerator::~BSDFCodeGenerator() {}

void BSDFCodeGenerator::processInput(MaterialX::ShaderInput* input,
    shared_ptr<BSDFCodeGeneratorShader> pBSDFGenShader, const string& bsdfInputVariable,
    string* pSourceOut)
{
    // Do we need local scope to avoid name collisions?
    bool addScope = false;

    // Get the shader stage.
    MaterialX::ShaderStage& ps = pBSDFGenShader->getStage(MaterialX::Stage::PIXEL);

    // Get the connection for the input (warn if null.)
    auto connection = input->getConnection();

    // Ignore input if no connection.
    // TODO: Handle this case.
    if (!connection)
    {
        AU_WARN("Input %s has no connection, ignoring.", input->getFullName().c_str());
        return;
    }

    // Get full variable name (with postfix numeral) for connection.
    string variableName = connection->getVariable();
    if (input->getConnection()->getNode()->getName() == "BSDFCodeGeneratorShaderGraph")
    {
        // If this a connection from the high-level shader graph, its a material input.
        auto inputName = input->getFullName();
        string path    = input->getPath();

        // Special case for inputs that are units, represent as built-in "distance_unit" parameter.
        // TODO: Can we infer this from the mtlx API?  If not we should add this, to avoid
        // hard-coded string searches.
        bool isUnit = false;
        if (inputName.find("unit_unit_to") != string::npos)
        {
            _hasUnits = true;
            isUnit    = true;
            if (_builtInIndexLookup.find("distance_unit") == _builtInIndexLookup.end())
            {
                _builtInIndexLookup["distance_unit"] = (int)_builtIns.size();
                _builtIns                            = { { "int", "distance_unit" } };
            }
        }

        // Process the graph input.
        pSourceOut->append("\t// Graph input " + path + "\n");
        auto paramIter = _parameterIndexLookup.find(path);
        if (!isUnit && paramIter == _parameterIndexLookup.end())
        {
            // MtlX code gen requires a scope, but we comment it out so variable scope not effected.
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL).addValue("//");
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL)
                .beginScope(MaterialX::Syntax::CURLY_BRACKETS);

            // If this is not one of the parameters to the setup function write the default value as
            // GLSL.
            _pGenerator->emitVariableDeclaration(input, "", *_pGeneratorContext, ps, true);

            // End the scope for declaration.
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL).addValue("//");
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL)
                .endScope(MaterialX::Syntax::CURLY_BRACKETS);

            // Append source for this input.
            pSourceOut->append("\t" + pBSDFGenShader->getNewSource() + ";\n");
        }
        else
        {

            // MtlX code gen requires a scope, but we comment it out so variable scope not effected.
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL).addValue("//");
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL)
                .beginScope(MaterialX::Syntax::CURLY_BRACKETS);

            // If this is one of the parameters to the setup function don't write the default value
            // in GLSL.
            _pGenerator->emitVariableDeclaration(input, "", *_pGeneratorContext, ps, false);

            // End the declaration scope.
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL).addValue("//");
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL)
                .endScope(MaterialX::Syntax::CURLY_BRACKETS);

            // Append declaration to source.
            pSourceOut->append("\t" + pBSDFGenShader->getNewSource());

            if (isUnit)
            {
                // the unit parameter is always first built-in.
                pSourceOut->append(" = " + _builtIns[0].second + ";\n");
            }
            else
            {
                // Append the parameter name.
                auto& param = _parameters[paramIter->second];
                if (param.paramType == ParameterType::MaterialProperty)
                    pSourceOut->append(" = material." + param.variableName + ";\n");
                else if (param.paramType == ParameterType::Texture)
                    pSourceOut->append(" = " + param.variableName + "_image_parameter;\n");
                param.glslType = pBSDFGenShader->syntax()->getTypeName(input->getType());
            }
        }

        // Set the variable name that will used to generate the output.result.
        variableName = input->getVariable();
    }
    else
    {
        // Get the node this connection is from and its implementation string.
        auto node       = connection->getNode();
        string implName = node->getImplementation().getName();

        // Create a temp variable to store the node output, if this node has already been generated
        // then this will be reused without generating again.
        // TODO: Handle multiple outputs.
        string outputTempVariable =
            "nodeOutTmp_" + connection->getNode()->getName() + "_" + connection->getName();

        // Only process the input if it hasn't already been processed.
        if (_processedNodes.find(node) == _processedNodes.end())
        {
            _processedNodes.insert(node);

            // Generate temp variables for the inputs, to avoid name collisions.
            auto inputs = node->getInputs();
            pSourceOut->append("\t//Temp input variables for " + node->getName() + " \n");

            // Create a temp output variable to store any externally-facing outputs.
            pSourceOut->append("\t" + pBSDFGenShader->syntax()->getTypeName(connection->getType()) +
                " " + outputTempVariable + "; //Temp output variable for " + connection->getName() +
                " \n");

            vector<string> outputVars;
            for (int i = 0; i < inputs.size(); i++)
            {
                // Get the input name and connection name it is coming from..
                auto nodeInput = inputs[i];
                string inputTempVariable =
                    "nodeTmp_" + nodeInput->getNode()->getName() + "_" + nodeInput->getName();

                // Create temp variable
                string inputType = pBSDFGenShader->syntax()->getTypeName(nodeInput->getType());
                pSourceOut->append("\t" + inputType + " " + inputTempVariable +
                    "; //Temp input variable for " + nodeInput->getName() + " \n");

                // Add to output variables.(passed to upstream input nodes) and code generator.
                outputVars.push_back(inputTempVariable);
                _pGenerator->addTempInputVariable(nodeInput, inputTempVariable);
            }

            // Recursively process inputs.
            for (int i = 0; i < inputs.size(); i++)
            {
                auto nodeInput = inputs[i];
                processInput(nodeInput, pBSDFGenShader, outputVars[i], pSourceOut);
            }

            // Check if we already have a definition for this node's implementation.
            // The definitions are shared between documents, and calls to generate.
            auto defIter           = _definitionMap.find(implName);
            size_t definitionIndex = 0xFFFFFFFF;
            if (defIter != _definitionMap.end())
            {
                definitionIndex = defIter->second;
            }
            else
            {
                // MtlX code gen requires a scope, but we comment it out so variable scope not
                // effected.
                pBSDFGenShader->getStage(MaterialX::Stage::PIXEL).addValue("//");
                pBSDFGenShader->getStage(MaterialX::Stage::PIXEL)
                    .beginScope(MaterialX::Syntax::CURLY_BRACKETS);

                // If not already generated (and not an empty string), store the function
                // definition.
                _pGenerator->emitFunctionDefinition(*node, *_pGeneratorContext, ps);

                // End scope for definition.
                pBSDFGenShader->getStage(MaterialX::Stage::PIXEL).addValue("//");
                pBSDFGenShader->getStage(MaterialX::Stage::PIXEL)
                    .endScope(MaterialX::Syntax::CURLY_BRACKETS);

                string defSource = pBSDFGenShader->getNewSource();
                if (defSource.size())
                {
                    definitionIndex          = _definitions.size();
                    _definitionMap[implName] = definitionIndex;
                    _definitions.push_back(
                        "\n// Definition for implementation " + implName + "\n" + defSource);
                }
            }

            // Begin with comment (referencing definition if there is one)
            pSourceOut->append("\t// Graph input function call " + input->getName());
            if (definitionIndex != 0xFFFFFFFF)
            {
                pSourceOut->append(" (See definition " + implName + ")");
            }
            pSourceOut->append("\n");

            // To avoid name collisions add local scope.
            // TODO: Fix indentation.
            pSourceOut->append("{\n");
            addScope = true;

            // MtlX code gen requires a scope, but we comment it out so variable scope not
            // effected.
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL).addValue("//");
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL)
                .beginScope(MaterialX::Syntax::CURLY_BRACKETS);

            // Emit function call for this input.
            _pGenerator->emitFunctionCall(*node, *_pGeneratorContext, ps);

            // End scope for function call.
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL).addValue("//");
            pBSDFGenShader->getStage(MaterialX::Stage::PIXEL)
                .endScope(MaterialX::Syntax::CURLY_BRACKETS);

            pSourceOut->append("\t" + pBSDFGenShader->getNewSource());

            pSourceOut->append("\t" + outputTempVariable);
            pSourceOut->append(" = " + variableName + ";// Output connection\n");
        }
        else
        {
            variableName = outputTempVariable;
        }
    }

    // Copy this output to the provided
    if (bsdfInputVariable.size())
    {
        pSourceOut->append("\t" + bsdfInputVariable);
        pSourceOut->append(" = " + variableName + ";// Output connection\n");
    }

    // End local scope (ensuring output variable setter is enclosed.)
    if (addScope)
    {
        pSourceOut->append("}\n");
    }
}

void BSDFCodeGenerator::clearDefinitions()
{
    // Clear the definitions, which are accumulated after each generate call.
    _definitions.clear();
    _definitionMap.clear();

    // Clear the includes and defs in the shader generator.
    _pGenerator->clearGeneratedDefinitions();
}

int BSDFCodeGenerator::generateDefinitions(string* pResultOut)
{
    // Combine the GLSL code stored in the definitions vector.
    *pResultOut = "";
    for (int i = 0; i < _definitions.size(); i++)
    {
        pResultOut->append(_definitions[i]);
    }

    // Return number of definitions.
    return (int)_definitions.size();
}

bool BSDFCodeGenerator::materialXValueToAuroraValue(
    Value* pValueOut, shared_ptr<MaterialX::Value> pMtlXValue)
{
    *pValueOut = Value();

    string glslType = pMtlXValue->getTypeString();
    if (glslType.compare("color3") == 0)
    {
        MaterialX::Color3 valData = pMtlXValue->asA<MaterialX::Color3>();
        *pValueOut                = glm::vec3(valData[0], valData[1], valData[2]);
        return true;
    }
    if (glslType.compare("vector2") == 0)
    {
        MaterialX::Vector2 valData = pMtlXValue->asA<MaterialX::Vector2>();
        *pValueOut                 = glm::vec2(valData[0], valData[1]);
        return true;
    }
    if (glslType.compare("boolean") == 0)
    {
        bool valData = pMtlXValue->asA<bool>();
        *pValueOut   = valData;
        return true;
    }
    if (glslType.compare("integer") == 0)
    {
        int valData = pMtlXValue->asA<int>();
        *pValueOut  = valData;
        return true;
    }
    if (glslType.compare("float") == 0)
    {
        float valData = pMtlXValue->asA<float>();
        *pValueOut    = valData;
        return true;
    }
    if (glslType.compare("string") == 0)
    {
        string valData = pMtlXValue->asA<string>();
        *pValueOut     = valData;
        return true;
    }

    return false;
}

bool BSDFCodeGenerator::materialXValueToAuroraPropertyValue(
    PropertyValue* pValueOut, shared_ptr<MaterialX::Value> pMtlXValue)
{
    *pValueOut = PropertyValue();

    string glslType = pMtlXValue->getTypeString();
    if (glslType.compare("color3") == 0)
    {
        MaterialX::Color3 valData = pMtlXValue->asA<MaterialX::Color3>();
        *pValueOut                = glm::vec3(valData[0], valData[1], valData[2]);
        return true;
    }
    if (glslType.compare("vector2") == 0)
    {
        MaterialX::Vector2 valData = pMtlXValue->asA<MaterialX::Vector2>();
        *pValueOut                 = glm::vec2(valData[0], valData[1]);
        return true;
    }
    if (glslType.compare("vector3") == 0)
    {
        MaterialX::Vector3 valData = pMtlXValue->asA<MaterialX::Vector3>();
        *pValueOut                 = glm::vec3(valData[0], valData[1], valData[2]);
        return true;
    }
    if (glslType.compare("vector4") == 0)
    {
        MaterialX::Vector4 valData = pMtlXValue->asA<MaterialX::Vector4>();
        *pValueOut                 = glm::vec4(valData[0], valData[1], valData[2], valData[3]);
        return true;
    }
    if (glslType.compare("boolean") == 0)
    {
        bool valData = pMtlXValue->asA<bool>();
        *pValueOut   = valData;
        return true;
    }
    if (glslType.compare("integer") == 0)
    {
        int valData = pMtlXValue->asA<int>();
        *pValueOut  = valData;
        return true;
    }
    if (glslType.compare("float") == 0)
    {
        float valData = pMtlXValue->asA<float>();
        *pValueOut    = valData;
        return true;
    }
    if (glslType.compare("string") == 0)
    {
        string valData = pMtlXValue->asA<string>();
        *pValueOut     = valData;
        return true;
    }
    AU_FAIL("Unrecognized MateriaLX value type:%s", glslType.c_str());
    return false;
}

PropertyValue::Type BSDFCodeGenerator::glslTypeToAuroraType(const string glslType)
{
    // Set the Aurora type based on GLSL type string.
    if (glslType.compare("vec3") == 0)
        return PropertyValue::Type::Float3;
    if (glslType.compare("vec2") == 0)
        return PropertyValue::Type::Float2;
    if (glslType.compare("float") == 0)
        return PropertyValue::Type::Float;
    if (glslType.compare("int") == 0)
        return PropertyValue::Type::Int;
    if (glslType.compare("bool") == 0)
        return PropertyValue::Type::Bool;

    // Fail if no valid mapping found.
    AU_FAIL("Unsupported GLSL type %s", glslType.c_str());
    return PropertyValue::Type::Undefined;
}

bool BSDFCodeGenerator::generate(const string& document, BSDFCodeGenerator::Result* pResultOut,
    const set<string> supportedBSDFInputs, const string& overrideDocumentName)
{
    // Processed MaterialX document string.
    string processedMtlXDocument;

    // Process the document string to replace document name if override name provided.
    if (!overrideDocumentName.empty())
    {
        // Regular expression to find strings in the form:
        //     <materialx version="1.38" colorspace="lin_rec709">  <standard_surface name =
        //     "XID_PlasticBlack"
        // and then retrieve document name: XID_PlasticBlack
        std::regex rgx("<\\s*materialx[^>]+>\\s*<\\s*\\S+\\s+name=\"([^\"]+)\"");
        std::smatch match;

        // Create a copy of document string.
        processedMtlXDocument = document;

        // Search for matches to the document name reg exp.
        if (std::regex_search(processedMtlXDocument, match, rgx))
        {
            // Retrieve the sub-expression with the document name.
            string documentName = match[1];

            // Replace all occurrences of document name with the override value.
            processedMtlXDocument =
                Foundation::replace(processedMtlXDocument, documentName, overrideDocumentName);
        }
        else
        {
            // Warn if the regular expression fails.
            AU_WARN("Failed to find document name in MaterialX XML");
        }
    }

    // Get reference to original or processed materialX document string.
    const string& mtlXDocument = processedMtlXDocument.empty() ? document : processedMtlXDocument;

    // Clear any previous data.
    _pGenerator->clearTempVariables();
    _processedNodes.clear();
    _parameters.clear();
    _parameterIndexLookup.clear();
    _builtInIndexLookup.clear();
    _materialProperties.clear();
    _materialPropertyDefaults.clear();
    _textures.clear();
    _builtIns.clear();
    _hasUnits = false;

    // Clear the setup code string.
    pResultOut->materialSetupCode = "";

    // Create new document object.
    MaterialX::DocumentPtr mtlxDocument = MaterialX::createDocument();

    // Read the XML into a document.
    try
    {
        MaterialX::readFromXmlString(mtlxDocument, mtlXDocument);
    }
    catch (const MaterialX::Exception& exception)
    {
        AU_ERROR("Failed to read MaterialX from document:\n%s\n", exception.what());
        return false;
    }
    MaterialX::DocumentPtr doc = mtlxDocument;

    // Write unit registry.
    _unitRegistry->write(mtlxDocument);

    // Return false and print error message, if any.
    string errorMessage;
    if (!mtlxDocument->validate(&errorMessage))
    {
        AU_ERROR("Invalid MaterialX document:\n%s", errorMessage.c_str());
        return false;
    }

    // Find all the terminal input values that will become the setup function parameters.
    vector<MaterialX::ElementPtr> stringValues;
    map<string, int> textureIndexLookup;
    for (MaterialX::ElementPtr elem : doc->traverseTree())
    {
        // Get full path to node.
        string path = elem->getNamePath();

        // Initialize parameter struct to be filled in if parameter is found.
        Parameter param;
        param.parameterIndex = (int)_parameters.size();

        // Have we found a parameter?
        bool foundParam = false;

        MaterialX::ValueElementPtr valueElem = elem->asA<MaterialX::ValueElement>();
        if (valueElem && valueElem->isA<MaterialX::Input>() && valueElem->hasValue())
        {
            // All ValueElement's are parameters.
            foundParam = true;

            // Create a parameter object from the ValueElement's input value (adsk texture node
            // values will be represented this way).
            auto type = valueElem->getType();

            // Fill in parameter based on type.
            if (type.compare("filename") == 0)
            {
                // Create texture parameter from the file ValueElement.
                param.path = processPath(path, true); // Remove the last and first part of path.
                param.variableName = pathToVariableName(param.path);
                param.index        = (int)_textures.size();
                param.paramType    = ParameterType::Texture;
                param.type         = "sampler2D";

                // Create the texture definition for this parameter.
                TextureDefinition tex;
                tex.name            = param.path;
                tex.defaultFilename = valueElem->getValue()->asA<string>();

                // Set linearize to if no color space or srgb_texture color space.
                string colorSpace = valueElem->getColorSpace();
                tex.linearize     = colorSpace.empty() || colorSpace.compare("srgb_texture") == 0;

                _textures.push_back(tex);
                textureIndexLookup[param.path] = param.index;
            }
            else if (type.compare("string") == 0)
            {
                // String parameters are hardcoded texture properties (e.g. wrap mode), must be
                // post-processed.
                stringValues.push_back(elem);
            }
            else
            {
                // All other ValueElement types become material properties.
                param.path         = processPath(path, false); // Remove only first section of path.
                param.variableName = pathToVariableName(param.path);
                param.index        = (int)_materialProperties.size();
                param.paramType    = ParameterType::MaterialProperty;
                param.type         = valueElem->getType();

                // Create uniform block property definition for parameter.
                PropertyValue propVal;
                materialXValueToAuroraPropertyValue(&propVal, valueElem->getValue());
                UniformBufferPropertyDefinition propDef(
                    param.path, param.variableName, propVal.type);
                _materialProperties.push_back(propDef);
                _materialPropertyDefaults.push_back(propVal);
            }
        }
        else
        {

            // image nodes and their children are not represented by ValueElement for some reason,
            // so get the type as attribute.
            string type = elem->getAttribute("type");
            if (!type.empty())
            {
                // Process string and filename nodes.
                if (type.compare("filename") == 0)
                {
                    // Found a filename parameter.
                    foundParam = true;

                    // Create texture parameter.
                    param.path = processPath(path, true); // Remove the last and first part of path.
                    param.variableName = pathToVariableName(param.path);
                    param.index        = (int)_textures.size();
                    param.paramType    = ParameterType::Texture;
                    param.type         = "sampler2D";

                    // Create the texture definition for this parameter.
                    TextureDefinition tex;
                    tex.name            = param.path;
                    tex.defaultFilename = elem->getAttribute("value");

                    // Set linearize to if no color space or srgb_texture color space.
                    string colorSpace = elem->getAttribute("colorspace");
                    tex.linearize = colorSpace.empty() || colorSpace.compare("srgb_texture") == 0;

                    _textures.push_back(tex);
                    textureIndexLookup[param.path] = param.index;
                }
                else if (type.compare("string") == 0)
                {
                    // Found a string parameter.
                    foundParam = true;

                    // String parameters are hardcoded texture properties (e.g. wrap mode), must be
                    // post-processed.
                    stringValues.push_back(elem);
                }
            }
        }

        // Add to setup function parameters.
        if (foundParam && !param.variableName.empty())
        {
            _parameterIndexLookup[path] = (int)_parameters.size();
            _parameters.push_back(param);
        }
    }

    // Process the hardcoded texture properties that will become sampler settings.
    // TODO: Fix this in MaterialX, so we have actual sampler objects, not error prone hard coded
    // magic property names.
    for (MaterialX::ElementPtr elem : stringValues)
    {
        string path    = elem->getNamePath();
        string txtPath = processPath(path, true);
        string valData = elem->getAttribute("value");
        auto iter      = textureIndexLookup.find(txtPath);
        if (iter != textureIndexLookup.end())
        {
            auto& texture = _textures[iter->second];
            if (elem->getName().compare("uaddressmode") == 0)
            {
                texture.addressModeU = valData;
            }
            else if (elem->getName().compare("vaddressmode") == 0)
            {
                texture.addressModeV = valData;
            }
        }
    }

    // Import the standard library.
    mtlxDocument->importLibrary(s_pStdLib);

    // Setup include paths.
    // TODO: This is just a guess.  How do we ensure all required includes are provided?
    MaterialX::StringMap& tokenSub =
        const_cast<MaterialX::StringMap&>(_pGenerator->getTokenSubstitutions());
    tokenSub["$fileTransformUv"] = "stdlib/genglsl/lib/mx_transform_uv.glsl";

    // Find renderable nodes.
    vector<MaterialX::TypedElementPtr> elements;
    unordered_set<MaterialX::ElementPtr> processedOutputs;
    MaterialX::findRenderableMaterialNodes(mtlxDocument, elements, false, processedOutputs);

    // Return false if no renderable nodes.
    // TODO: Better error handling.
    if (elements.size() == 0)
    {
        AU_ERROR("No renderable nodes in MaterialX document");
        return false;
    }

    // Assume material is first element in the XML file.
    string materialNodeName = elements[0]->getName();

    // Get the material nodes, return false if empty.
    // TODO: Better error handling.
    auto materialNodes = mtlxDocument->getMaterialNodes();
    if (elements.size() == 0)
    {
        AU_ERROR("Empty material in MaterialX document");
        return false;
    }

    // Find the material node using name from element.
    MaterialX::NodePtr materialNode = nullptr;
    for (int i = 0; i < materialNodes.size(); i++)
    {
        if (materialNodes[i]->getName() == materialNodeName)
        {
            materialNode = materialNodes[i];
            break;
        }
    }

    // Return false if find failed.
    // TODO: Better error handling.
    if (materialNode == nullptr)
    {
        AU_ERROR("Failed to find material node");
        return false;
    }

    // Get the shader nodes.
    vector<MaterialX::NodePtr> shaderNodes = MaterialX::getShaderNodes(materialNode);
    if (shaderNodes.empty())
    {
        AU_ERROR("No shader nodes in MaterialX document");
        return false;
    }

    // Find the surface node for shader.
    MaterialX::TypedElementPtr shaderNodeElement = nullptr;
    for (MaterialX::NodePtr shaderNode : shaderNodes)
    {
        if ((shaderNode->getType() == MaterialX::SURFACE_SHADER_TYPE_STRING) &&
            (shaderNode->getCategory() == _surfaceShaderNodeCategory))
        {
            shaderNodeElement = shaderNode;
            break;
        }
    }
    if (!shaderNodeElement)
    {
        AU_ERROR("Failed to find surface shader in material");
        return false;
    }

    // Get the node for MaterialX shader.
    MaterialX::NodePtr shaderNode = shaderNodeElement->asA<MaterialX::Node>();

    // Build a set of the BSDF inputs used by the shader nodes.  These will be the outputs to the
    // setup function.
    auto graphInputs = shaderNode->getInputs();
    set<string> bsdfInputSet;
    for (auto gi : graphInputs)
    {
        string bsdfInputName = gi->getName();
        if (supportedBSDFInputs.empty() ||
            supportedBSDFInputs.find(bsdfInputName) != supportedBSDFInputs.end())
            bsdfInputSet.insert(bsdfInputName);
    }

    // Get the implementation for the node.
    MaterialX::InterfaceElementPtr shaderNodeDefImpl = shaderNode->getImplementation();
    if (!shaderNodeDefImpl)
    {
        AU_ERROR("Failed to find nodegraph implementation for the surface shader");
        return false;
    }
    string surfaceShaderNodeType = shaderNodeDefImpl->getName();

    // Create a shader graph from the surface node.
    MaterialX::ShaderGraphPtr graph;
    try
    {
        graph = MaterialX::ShaderGraph::create(
            nullptr, "BSDFCodeGeneratorShaderGraph", shaderNodeElement, *_pGeneratorContext);
    }
    catch (MaterialX::ExceptionShaderGenError& ex)
    {
        AU_ERROR("Exception in MaterialX code:%s", ex.what());
        return false;
    }
    shared_ptr<BSDFCodeGeneratorShader> pBSDFGenShader =
        make_shared<BSDFCodeGeneratorShader>("BSDFCodeGeneratorShader", graph);
    MaterialX::ShaderPtr shader = dynamic_pointer_cast<MaterialX::Shader>(pBSDFGenShader);

    // Find the surface shader node.
    MaterialX::ShaderNode* surfaceShaderNode = nullptr;
    for (MaterialX::ShaderNode* node : graph->getNodes())
    {
        if (node->getImplementation().getName() == surfaceShaderNodeType)
        {
            surfaceShaderNode = node;
            break;
        }
    }
    if (!surfaceShaderNode)
    {
        AU_ERROR("No surface shader node of type %s found", surfaceShaderNodeType.c_str());
        return false;
    }

    _topLevelShaderNodeName = surfaceShaderNode->getName();

    // Create the active inputs and outputs.
    _activeBSDFInputs.clear();
    _activeBSDFInputNames.clear();

    // Build the body of the setup function from the surface shader node inputs.
    string functionBody      = "";
    auto surfaceShaderInputs = surfaceShaderNode->getInputs();
    for (int ssi = 0; ssi < surfaceShaderInputs.size(); ssi++)
    {
        // Is this shader input one of the outputs we are interested in ?
        auto surfaceShaderInput = surfaceShaderInputs[ssi];
        string inputName        = surfaceShaderInput->getName();

        // Process inputs that are in the set of BSDF inputs for this material.
        string bsdfInputVariable;
        if (bsdfInputSet.find(inputName) != bsdfInputSet.end())
            bsdfInputVariable = inputName;
        if (!bsdfInputVariable.empty())
        {
            // Process the shader input.
            processInput(surfaceShaderInput, pBSDFGenShader, bsdfInputVariable, &functionBody);

            // Add to list of active BSDF inputs.
            _activeBSDFInputNames.push_back(bsdfInputVariable);
            _activeBSDFInputs[bsdfInputVariable] =
                pBSDFGenShader->syntax()->getTypeName(surfaceShaderInput->getType());
        };
    }

    // Set the material properties and textures in result.
    pResultOut->materialProperties       = _materialProperties;
    pResultOut->materialPropertyDefaults = _materialPropertyDefaults;
    pResultOut->textureDefaults          = _textures;
    pResultOut->hasUnits                 = _hasUnits;

    // Set the texture names in the result.
    pResultOut->textures.clear();
    for (int i = 0; i < pResultOut->textureDefaults.size(); i++)
    {
        pResultOut->textures.push_back(pResultOut->textureDefaults[i].name);
    }

    // Create the contents of the material struct.
    string structProperties;
    for (int i = 0; i < pResultOut->materialProperties.size(); i++)
    {
        string glslType = getGLSLStringFromType(pResultOut->materialProperties[i].type);

        structProperties.append(
            "\t" + glslType + " " + pResultOut->materialProperties[i].variableName + ";\n");
    }

    // Create a hash from the contents of the setup function and the material struct. This is used
    // to uniquely identify the shader code generated for this material.  It is possible to have
    // identical functions with different material structs (as struct properties can be unused.)
    // TODO: Strip out unused material parameters.
    size_t structHash        = hash<string> {}(structProperties);
    pResultOut->functionHash = hash<string> {}(functionBody);
    Foundation::hashCombine(pResultOut->functionHash, structHash);

    // Create setup function name from hash.
    stringstream sstream;
    sstream << "setupMaterial_" << Foundation::sHash(pResultOut->functionHash);
    pResultOut->setupFunctionName = sstream.str();

    // Create material struct type name from hash.
    sstream = stringstream();
    sstream << "Material_" << Foundation::sHash(pResultOut->functionHash);
    pResultOut->materialStructName = sstream.str();

    // Create the GLSL code for the material struct (containing all material properties).
    pResultOut->materialStructCode = "struct " + pResultOut->materialStructName + " {\n";
    pResultOut->materialStructCode.append(structProperties);
    pResultOut->materialStructCode.append("};\n");

    // Create the function prototype from the function name, active inputs and outputs.
    pResultOut->materialSetupCode = "void " + pResultOut->setupFunctionName + "(\n";

    // Keep track of total input and output parameter count.
    int numParams = 0;

    // The first argument is always the material struct.
    pResultOut->materialSetupCode.append("\t" + pResultOut->materialStructName + " material");

    // Add the texture inputs to the function prototype.
    for (int i = 0; i < _textures.size(); i++)
    {
        pResultOut->materialSetupCode.append(",\n");

        // Add the code for this input to the prototype.
        pResultOut->materialSetupCode.append(
            "\tsampler2D " + _textures[i].name + "_image_parameter");

        numParams++;
    }

    // The distance unit (if used) is last input parameter in setup function prototype.
    if (_hasUnits)
    {
        pResultOut->materialSetupCode.append(",\n");

        // Add the code for the distance unit.
        pResultOut->materialSetupCode.append("\tint " + _builtIns[0].second);

        numParams++;
    }

    // The active BSDF inputs become output parameters to the function prototype.
    pResultOut->bsdfInputs.clear();
    for (auto bsdfInputName : _activeBSDFInputNames)
    {
        auto activeTypeIter = _activeBSDFInputs.find(bsdfInputName);
        if (activeTypeIter != _activeBSDFInputs.end())
        {
            // Create variable name using output name and suffix.
            string outputVarName = bsdfInputName;

            // Append comma to previous line, if any.
            pResultOut->materialSetupCode.append(",\n");

            // Convert GLSL type to Aurora type enum.
            PropertyValue::Type auroraType = glslTypeToAuroraType(activeTypeIter->second);

            // Add this output to the results.
            pResultOut->bsdfInputs.push_back({ bsdfInputName, auroraType });

            // Add the code for this output to the prototype.
            pResultOut->materialSetupCode.append(
                "\tout " + activeTypeIter->second + " " + outputVarName);

            // Increment parameter count.
            numParams++;
        }
    }

    // Add body wrapped in braces.
    pResultOut->materialSetupCode.append(")\n{\n");
    pResultOut->materialSetupCode.append(functionBody);
    pResultOut->materialSetupCode.append("}\n");

    return true;
};

} // namespace MaterialXCodeGen
} // namespace Aurora
